#summary Me sorting out what the differences between deb and rpm package hooks are.
 
<wiki:toc max_depth="2" />

= Introduction =

I'm adding RPM support to framewerk.  It turns out, unsurprisingly, the package scripts have different semantics in RPM vs. DEB.  Most people will probably just develop for one or the other so they can write scripts into {{{fw-pkgin/}}} that don't work for both, no big deal.  However sometimes cross-packaging hooks need to be written (e.g., automatic [http://code.google.com/p/erlrc/ erlrc] integration into fw-template-erlang [FwTemplateErlangWalkthrough fw-template-erlang]), which is the point of the {{{make-hook}}} package method, but now I have to figure it out.

From an [http://fedoraproject.org/wiki/Packaging/ScriptletSnippets RPM reference] and a [http://www.debian.org/doc/debian-policy/ch-maintainerscripts.html DEB reference], I cobbled together this understanding.

= Script Correspondence =

== Install ==

|| RPM || DEB ||
||  %pretrans of new package || - ||
|| %pre of new package || new-preinst install ||
|| _new package installed_ || _new package files unpacked_ ||
|| %post of new package || - ||
|| %posttrans of new package || postinst configure most-recently-configured-version ||

Note the arguments are different:
  * RPM passes an installation count to scriptlets, and does not pass previous version information.
  * DEB passes a sum type argument to scriptlets, as well as previous version information.

== Updates ==

|| RPM || DEB ||
||  %pretrans of new package || new-prerm failed-upgrade old-version[[#2 2]] ||
||  %pre of new package || new-preinst upgrade old-version ||
|| _new package installed_ || _new package files unpacked_ ||
|| %post of new package || - ||
|| %preun of old package || old-postrm upgrade new-version [[#1 1]]  || 
|| _removal of old package_ || _"old but not new" package files removed_ ||
|| %postun of old package || - ||
|| %posttrans of new package || postinst configure most-recently-configured-version ||

Correspondence here is sketchy, due to the different models: RPM {{{%postun}}} happens after the old package files are removed, whereas DEB {{{postrm}}} happens after the new package files are installed but before the old package files are removed.

Again the arguments are different, and the result is more painful here because knowing previous version information is more critical for upgrade than for install (where there is no previous version) or remove (where the current version is the previous version).  Recent versions of RPM can be called from scriptlets but presumably {{{rpm -q}}} will return a different result after the _new package installed_ step in the above chain.

== Remove ==

|| RPM || DEB ||
||  %pretrans of old package || - ||
|| %preun of old package || prerm remove ||
|| _removal of old package_ || _package files are removed_ ||
|| %postun of old package || postrm remove ||
|| %posttrans of old package || - ||

Correspondence here is really good.

= Framewerk Abstraction =

Right now we have the following files in {{{fw-pkgin/}}}:
{{{
 ls fw-pkgin/pre* fw-pkgin/post* fw-pkgin/s*
fw-pkgin/post-install*  fw-pkgin/pre-install*  fw-pkgin/start*
fw-pkgin/post-remove*   fw-pkgin/pre-remove*   fw-pkgin/stop*
}}}
The challenge is to interpret these in such a way as to have them mean about the same thing in RPM vs. DEB and not break alot of current packages (which were written prior to RPM support).

Therefore, I'll think I'll make RPM look like DEB.  This basically means decoding the "installation count" argument that RPM provides and use that to emulate the DEB sum type.  In addition I'll have to do something in {{{%pretrans}}} to record the old and new versions.

Thus, DEB script semantics continue to be the mapping
  * preinst -> pre-install
  * postinst -> post-install
  * prerm -> pre-remove
  * postrm -> post-remove
which means that you can look for extra arguments that indicate the "exception handling" portions of the DEB package management model; these arguments will just never be encountered when the project is rendered as an RPM package.

== Mapped RPM Installation ==

|| RPM || Framewerk Mapping ||
||  %pretrans of new package || - ||
|| %pre of new package || pre-install install ||
|| _new package installed_ || _new package files unpacked_ ||
|| %post of new package || - ||
|| %posttrans of new package || post-install configure "" ||

== Mapped RPM Upgrade ==

|| RPM || Framewerk Mapping ||
||  %pretrans of new package || - ||
||  %pre of new package || (new) pre-remove failed-upgrade old-version && (new) pre-install upgrade old-version ||
|| _new package installed_ || _new package files unpacked_ ||
|| %post of new package || - ||
|| %preun of old package || (new) post-remove failed-upgrade new-version [[#1 1]]  || 
|| _removal of old package_ || _"old but not new" package files removed_ ||
|| %postun of old package || - ||
|| %posttrans of new package || (new) post-install configure previously-installed version ||

Yes it's wierd that the argument to pre-remove is {{{failed-upgrade}}}, but one should be writing one's DEB pre-remove that way [[#2 2]].

== Mapped RPM Remove ==

|| RPM || Framewerk Mapping ||
||  %pretrans of old package || - ||
|| %preun of old package || pre-remove remove ||
|| _removal of old package_ || _package files are removed_ ||
|| %postun of old package || post-remove remove ||
|| %posttrans of old package || - ||

= Footnotes =

== 1 ==

In the DEB model {{{new-postrm failed-upgrade old-version}}} is invoked if {{{old-postrm upgrade new-version}}} fails, so one can ensure the new postrm is always called if desired.  The RPM model appears to force using the old {{{%postun}}}, but we work around this.

== 2 ==
In the DEB model, {{{old-prerm upgrade new-version}}} is invoked first, but if this fails then {{{new-prerm failed-upgrade old-version}}} has a chance to "handle the exception".  Since RPM uses the new script for {{{%pretrans}}}, I corresponded it with {{{new-prerm}}}.  In practice this means {{{old-prerm upgrade new-version}}} should just be {{{exit 1}}} if pre-remove is to do something non-trivial on upgrade.  Easiest of all: just use pre-install, since the new version is always invoked on upgrade.