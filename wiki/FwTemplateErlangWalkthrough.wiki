#summary Basic introduction to fw-template-erlang.

= Introduction =

fw-template-erlang is the framewerk Erlang template.  It features:
  * [http://erlang.org/doc/man/cover.html cover] integration with 'make check'
  * [http://www.erlang.org/doc/apps/edoc/index.html edoc] integration for documentation.
  * [http://svn.process-one.net/contribs/trunk/eunit/doc/index.html eunit] integration with 'make check'
  * generates an [http://www.erlang.org/doc/design_principles/applications.html#7.3 otp compliant application file] by scanning the source code
  * standard make rules to drive the erlang compiler

This walkthrough demonstrates fw-template-erlang.

= Prerequisites =

[FwTemplateErlangInstall fw-template-erlang installed]

It's very helpful to have done the [FramewerkWalkthrough framewerk walkthrough].

= Details =

== Initialize the project ==

First, set up the project with fw-init [FramewerkWalkthrough#Initialize_the_project in the usual way].
{{{
% env CVSROOT="YOURCVSROOT" fw-init --name myproject --template erlang --revision cvs
}}}
Changing directory into the project,
{{{
% cd myproject/
% cvs -n -q up
A .cvsignore
A AUTHORS
A ChangeLog
A Makefile.am.local
A NEWS
A README
A bootstrap
A configure.ac.local
A doc/.cvsignore
A doc/Makefile.am.local
A doc/overview.edoc
A fw-pkgin/.cvsignore
A fw-pkgin/Makefile.am.local
A fw-pkgin/config
A fw-pkgin/post-install
A fw-pkgin/post-remove
A fw-pkgin/pre-install
A fw-pkgin/pre-remove
A fw-pkgin/start
A fw-pkgin/stop
A src/.cvsignore
A src/Makefile.am.local
A src/myapp.erl
A tests/.cvsignore
A tests/Makefile.am.local
}}}

== Anatomy of the top level ==

The root directory of the project now looks like:
{{{
% ls
AUTHORS  ChangeLog          NEWS    bootstrap           doc  fw-pkgin  tests
CVS      Makefile.am.local  README  configure.ac.local  fw   src
}}}
Here's a breakdown:
  * {{{AUTHORS, CVS, ChangeLog, NEWS, README, bootstrap, fw, fw-pkgin, configure.ac.local, Makefile.am.local}}}: these have the same meanings as in [FramewerkWalkthrough#Anatomy_of_the_top_level other framewerk templates].
  * {{{src, tests}}}: Erlang source code (.erl, .hrl) is placed in {{{src/}}}, and unit tests in {{{tests/}}}.

== Configure the project ==

As with [FramewerkWalkthrough#Configure_the_project other framewerk templates], {{{fw-pkgin/config}}} is used to configure the project.  However some new variables are available with this template.
{{{
% cat fw-pkgin/config
# The FW_PACKAGE_MAINTAINER field is populated with the
# environment variable FW_PACKAGE_DEFAULT_MAINTAINER if non-empty

FW_PACKAGE_NAME="myproject"
FW_PACKAGE_VERSION="0.0.0"
FW_PACKAGE_MAINTAINER="root <root@ec2-67-202-48-148.compute-1.amazonaws.com>"
FW_PACKAGE_SHORT_DESCRIPTION="A short description."
FW_PACKAGE_DESCRIPTION=`cat README`
FW_PACKAGE_ARCHITECTURE_DEPENDENT="0"

# Dependency information.  The native syntax corresponds to Debian,
# http://www.debian.org/doc/debian-policy/ch-relationships.html
# Section 7.1 "Syntax of Relationship Fields"
#
# For other packaging systems, the syntax is translated for you.

FW_PACKAGE_DEPENDS=""
FW_PACKAGE_CONFLICTS=""
FW_PACKAGE_PROVIDES=""
FW_PACKAGE_REPLACES=""

FW_PACKAGE_BUILD_DEPENDS=""
FW_PACKAGE_BUILD_CONFLICTS=""

# uncomment and set manually if autodetection of modules is incorrect
# FW_ERL_APP_MODULES=""

# uncomment and set manually if autodetection of registered processes is incorrect
# FW_ERL_APP_REGISTERED=""

# uncomment and set manually if autodetection of start module is incorrect
# FW_ERL_APP_START_MODULE=""

# uncomment to define start args to the start module.  should be an erlang
# expression which evaluates to a list.
# FW_ERL_APP_START_ARGS="[]"

# uncomment if the module line being generated is incorrect and you want
# to override it.
# FW_ERL_APP_MOD_LINE="{ mod, { $FW_ERL_APP_START_MODULE, $FW_ERL_APP_START_ARGS } },"

# uncomment to define the application environment variables. should be an
# erlang expression which evaluates to a list.
# FW_ERL_APP_ENVIRONMENT="[]"
}}}
The extra variables are mostly related to creation of an 
[http://www.erlang.org/doc/design_principles/applications.html#7.3 otp compliant application file].  This mostly just works but in case it doesn't 
you have override control via these variables.

== Build the project ==

Build the project [FramewerkWalkthrough#Build_the_project the usual way],
{{{
% ./bootstrap && ./build
}}}

=== Makefile.otp ===

Now there should be a {{{Makefile.otp}}} in the root directory of the project.
{{{
% cat Makefile.otp
erlappdir="@ERLAPPDIR@"
erlappsrcdir="$(erlappdir)/src"
erlappebindir="$(erlappdir)/ebin"
erlappprivdir="$(erlappdir)/priv"
erlappincludedir="$(erlappdir)/include"
erldocdir="@ERLDOCDIR@"

SUFFIXES = .beam .erl .P

ERLCFLAGS ?= +debug_info -pa ../src -I ../src

# put an overly broad dependency on .hrl for now, 
# which will cause some spurious extra compiles
# TODO: depgen for erlang

%.beam: %.erl $(wildcard *.hrl)
        erlc ${ERLCFLAGS} ${$*_ERLCFLAGS} $<

%.P: %.erl $(wildcard *.hrl)
        erlc +"'P'" ${ERLCFLAGS} ${$*_ERLCFLAGS} $<

.%.beam_ok: %.beam
        dialyzer -c $*.beam
        touch $@

.%.erl_ok: %.erl
        dialyzer --src -c $*.erl
        touch $@

.dialyzer_ok: $(wildcard *.erl)
        dialyzer ${DIALYZERFLAGS} --src -c .
        touch $@

CLEANFILES +=                   \
  $(wildcard *.P)               \
  $(wildcard *.beam)            \
  $(wildcard .*.beam_ok)        \
  $(wildcard .*.erl_ok)         \
  .dialyzer_ok                  \
  erl_crash.dump

include $(top_srcdir)/fw/build/automake/check-shell.am
include $(top_srcdir)/fw/build/automake/gnu-make-check.am
}}}

Notes:
  * The standard directory targets erlappsrc, erlappebin, erlapppriv, and erlappinclude are defined, corresponding to the [http://www.erlang.org/doc/design_principles/applications.html#7.4 otp application directory structure].
  * Automatic rules for building a {{{.beam}}} (or a {{{.P}}}) from the corresponding {{{.erl}}} file.  These are parametrized by ${ERLCFLAGS} globally and ${${{{*_}}}ERLCFLAGS} per target.  In other words, foo.beam can be built from foo.erl, and the compilation line would be
{{{
erlc ${ERLCFLAGS} ${foo_ERLCFLAGS} foo.erl
}}}
  * Unless otherwise set, ERLCFLAGS defaults to something reasonable.
  * Some rules are defined to drive the dialyzer.

=== src/ ===

The {{{src/}}} directory should contain something like
{{{
% ls src
CVS          Makefile.am.local        fw-erl-app-template.app.in  myproject.app
Makefile     Makefile.in              myapp.beam
Makefile.am  fw-erl-app-template.app  myapp.erl
}}}
Here's the breakdown:
  * {{{CVS}}}: revision control specific
  * {{{Makefile.in, Makefile}}}: generated by automake/autoconf
  * {{{Makefile.am}}}: a link to the Makefile.am installed with fw-template-erlang
  * {{{Makefile.am.local}}}: this is where you can put any additional (auto)make commands beyond what is supplied by the template.
  * {{{fw-erl-app-template.app, fw-erl-template-app.in}}}: intermediate files in the automatic generation of the otp compliant application file.
  * {{{myproject.app}}}: the automatically generated otp compliant application file.
  * {{{myapp.erl}}}: simple example application installed with the template
  * {{{myapp.beam}}}: compiled version of myapp.erl