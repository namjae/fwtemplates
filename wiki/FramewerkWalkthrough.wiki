#summary Basic introduction to framewerk.

= Introduction =

Framewerk ships with support for:
  * automake build
  * cvs revision control
  * debian packaging
  * script template
This particular combination of features is packed into the initial tarball because framewerk is self-building so this was the set of things I needed to get going.

This walkthrough demonstrates framewerk via the script template.

= Prerequisites =

Framewerk installed.

= Details =

== Initialize the project ==

First, set up the project with fw-init [[#1 1]].
{{{
% env CVSROOT="YOURCVSROOT" fw-init --name myproject --template script --revision cvs
}}}
Generally template {{{foo}}} is initialized using {{{fw-init}}} with argument {{{--template foo}}}, although templates may define other required arguments to {{{fw-init}}}.

Changing directory into the project,
{{{
% cd myproject
% cvs -n -q up
A .cvsignore
A AUTHORS
A ChangeLog
A Makefile.am.local
A NEWS
A README
A bootstrap
A configure.ac.local
A bin/.cvsignore
A bin/Makefile.am.local
A bin/myscript
A fw-pkgin/.cvsignore
A fw-pkgin/Makefile.am.local
A fw-pkgin/config
A fw-pkgin/post-install
A fw-pkgin/post-remove
A fw-pkgin/pre-install
A fw-pkgin/pre-remove
A fw-pkgin/start
A fw-pkgin/stop
A tests/.cvsignore
A tests/Makefile.am.local
A tests/testmyscript
}}}
notice {{{.cvsignore}}} files have been made by the template corresponding to files the template feels should not be under revision control (e.g., for automake build based templates, Makefiles are generated and therefore not checked in).  Framewerk interacts with the revision control system via an abstraction layer so when using other revision control systems the template will indicate files should be ignored using the appropriate method. [[#2 2]]

== Anatomy of the top level ==

The root directory of the project now looks like:
{{{
% ls
AUTHORS                 NEWS                    configure.ac.local
CVS/                    README                  fw@
ChangeLog               bin/                    fw-pkgin/
Makefile.am.local       bootstrap*              tests/
}}}
Here's a breakdown:
  * {{{AUTHORS, ChangeLog, NEWS, README}}}: these are files inherited from the conventions of automake.  By default framewerk gets the long package description from the {{{README}}}, but otherwise these files are ignored by framewerk.
  * {{{CVS}}}: revision control specific
  * {{{bootstrap}}}: framewerk generally tries not to check in important scripts into your project, so that the project's behaviour can be easily changed by upgrading framewerk.  however bootstrap is installed and checked-in to get things going.[[#5 5]] 
  * {{{Makefile.am.local}}}: this is where you can put any additional (auto)make commands beyond what is supplied by the template.  the template will link in a {{{Makefile.am}}} which contains a directive to include your {{{Makefile.am.local}}}.[[#7 7]]
  * {{{configure.ac.local}}}: this is where you can put any additional autoconf commands beyond what is supplied by the template.  the template will link in a {{{configure.ac}}} which contains a directive to include your {{{configure.ac.local}}}.[[#7 7]]
  * {{{bin, tests}}}: the script template creates a {{{bin}}} directory to contain your scripts, and {{{tests}}} directory to contain the tests for those scripts.  different templates will create additional directories.
  * {{{fw}}}: this is a link to the installation of framewerk on the local system (or, in a dist tarball, it is a copy of the installation of framewerk at {{{make dist}}} time).  generally you shouldn't have to look in here.[[#6 6]]
  * {{{fw-pkgin}}}: this directory contains files that configure how framewerk builds packages.

== Configure the project ==

Edit {{{fw-pkgin/config}}} in your favorite editor.  It consists of some shell variable assignments.
{{{
# The FW_PACKAGE_MAINTAINER field is populated with the 
# environment variable FW_PACKAGE_DEFAULT_MAINTAINER if non-empty

FW_PACKAGE_NAME="myproject"
FW_PACKAGE_VERSION="0.0.0"
FW_PACKAGE_MAINTAINER="Paul Mineiro <paul-fw@mineiro.com>"
FW_PACKAGE_SHORT_DESCRIPTION="A short description."
FW_PACKAGE_DESCRIPTION="`cat README`"
FW_PACKAGE_ARCHITECTURE_DEPENDENT="1"

# Dependency information.  The native syntax corresponds to Debian,
# http://www.debian.org/doc/debian-policy/ch-relationships.html
# Section 7.1 "Syntax of Relationship Fields"
# 
# For other packaging systems, the syntax is translated for you.

FW_PACKAGE_DEPENDS=""
FW_PACKAGE_CONFLICTS=""
FW_PACKAGE_PROVIDES=""
FW_PACKAGE_REPLACES=""

FW_PACKAGE_BUILD_DEPENDS=""
FW_PACKAGE_BUILD_CONFLICTS=""
}}}
These variables affect how packages (and dist tarballs) are built.  For instance currently {{{FW_PACKAGE_ARCHITECTURE_DEPENDENT="1"}}} so a binary package will be built for the host architecture.  If {{{FW_PACKAGE_ARCHITECTURE_DEPENDENT="0"}}} then a binary package will be built for the "all" architecture.

Note some dependencies are added for you automatically by the template and are not listed explicitly.  For instance a build dependency on framewerk is automatically generated in this case. [[#3 3]]

== Build the project ==

All framewerk projects build the same way.
{{{
% ./bootstrap && ./build
}}}
The template should have created a working project which can be built in this way or the template has a bug.  Also there should be no new non-ignored files according the revision control system or the template has a bug.

Maintainer mode is used such that if {{{fw-pkgin/config}}} is modified, bootstrap and build are essentially re-run, so there is typically no need to run bootstrap at any time other than project check-out (although, bootstrap is useful to escape from snafus).

You can also test the project via
{{{
% make check
}}}
All templates should initialize a project in a state which passes {{{make check}}} or the template has a bug.[[#4 4]]

== Modify the project ==

Generally working with framewerk is like working with automake but with the common bits done for you already.[[#8 8]]  So to add stuff to the project you're going to have to know some automake.  

If you wanted to add another script to the project you could create a file like
{{{
% cat > bin/mynewscript
#! /bin/sh

echo "awesome"
% chmod +x bin/mynewscript
}}}
and then edit {{{bin/Makefile.am.local}}} to look like:
{{{
% cat bin/Makefile.am.local
# put whatever (auto)make commands here, they will be included from Makefile.am

dist_bin_SCRIPTS =              \
  myscript                      \
  mynewscript
}}}
Framewerk uses {{{make install}}} to determine the contents of your package.  This means that a package made from this project will want to install {{{mynewscript}}} in {{{/usr/bin}}}.[[#9 9]] 

You should also make a test for your new script:
{{{
% cat > tests/testmynewscript
#! /bin/sh

output=`../bin/mynewscript`

test "x$output" = "xawesome"
% chmod +x tests/testmynewscript
}}}
and add then edit {{{tests/Makefile.am.local}}} to make it look like
{{{
% cat tests/Makefile.am.local
# put whatever (auto)make commands here, they will be included from Makefile.am

TESTS =         \
  testmyscript  \
  testmynewscript

EXTRA_DIST +=   \
  testmyscript  \
  testmynewscript
}}}

Now re-run the tests.
{{{
% make -s check
Making check in fw-pkgin
Making check in bin
 cd .. && /usr/local/bin/bash /usr/home/pmineiro/src/myproject/missing --run automake-1.10 --foreign  bin/Makefile
 cd .. && /usr/local/bin/bash ./config.status bin/Makefile 
config.status: creating bin/Makefile
Making check in tests
 cd .. && /usr/local/bin/bash /usr/home/pmineiro/src/myproject/missing --run automake-1.10 --foreign  tests/Makefile
 cd .. && /usr/local/bin/bash ./config.status tests/Makefile 
config.status: creating tests/Makefile
PASS: testmyscript
PASS: testmynewscript
==================
All 2 tests passed
==================
}}}

== Making a package ==

If you installed framewerk as a debian package on your system (as opposed to {{{make install}}} from a source package) then you should've seen a line like
{{{
checking for native package type... deb (autodetected)
}}}
in the output of {{{configure}}}.  If you see
{{{
checking for native package type... none (autodetected)
}}}
then either you didn't install framewerk as a package or else you're using a packaging system that framewerk doesn't recognize.  Right now it only recognizes debian package format (which includes fink on OS/X), but new package types can be provided via additional packages.[[#10 10]]

= Footnotes =

== 1 ==
Alternatively, if you are too young to remember cvs, you can initialize the project without revision control.
{{{
% fw-init --name mynorevproject --template script --revision none
}}}

== 2 ==
In practice, the only other revision control system to be ported to the framewerk API is subversion, which is not that different than cvs.  So maybe the abstraction is not abstract enough.

== 3 ==
For the truly curious, you can see how the template is modifying the config file by running
{{{
% fw-exec template/script/load-config
}}}
in the root directory of the project.

== 4 ==
Technically speaking this only required for templates which use automake to build.  Right now, however, that is all of them.

== 5 ==
It does pass a version number to fw-bootstrap so that, in theory, framewerk has a chance to upgrade it when it is run.

== 6 ==
There needs to be a whole wiki page about this feature, but here's a quick note instead.
Any file located in {{{fw/path/basename}}} relative to the root directory of your project can be overridden by a file {{{fw.local/path/basename}}} of the same name under {{{fw.local}}} in your root directory.  So for instance you could override the way the script template loads the config file by creating a {{{fw.local/template/script/load-config}}} file.  This escape hatch is here so that in case framewerk is getting in your way you can deal with it.

== 7 ==
The framewerk philosophy is to try to do the right thing by default but be able to be overridden if necessary.  So for {{{Makefile.am.local}}} and {{{configure.ac.local}}} files, if you for some reason can't work with the installed {{{Makefile.am}}} and {{{configure.ac}}} files and their include strategy, you can create your own {{{Makefile.am}}} and/or {{{configure.ac}}} and check them into your project.  If framewerk sees that you have these files, it will not link against the installed versions.  Note the disadvantage of doing this is that you no longer get your project automatically updated when framewerk is upgraded, so it should only be done when necessary.

== 8 ==
Which is weird because that's what automake said about make and autoconf.

== 9 ==
Assuming the prefix is {{{/usr}}}.  {{{/usr}}} is the default prefix for framewerk projects, but can be overridden, e.g. via the {{{--prefix}}} argument to {{{configure}}}.

== 10 ==
I haven't actually written a package to support any other package type.